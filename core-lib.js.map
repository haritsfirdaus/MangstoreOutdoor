{"version":3,"file":"core-lib.js","mappings":"y1BAgBA,MAAMA,EAAeC,OAAOC,OAAO,OAoDnC,SAnDA,SAA2BC,EAAUC,GACjC,KAAK,QAASD,GAAW,CACrB,IAAIA,EAASE,SAKT,OAAO,KAJPF,EAAWA,EAASG,SAM5B,CACA,MAAMC,EAAMJ,EACNK,EAASR,EAAaO,GAC5B,GAAIC,EACA,OAAOA,EAEX,GAAoB,MAAhBL,EAAS,GAAY,CACrB,MAAMM,EAAKC,SAASC,cAAcR,GAC9B,EAOJA,EAAWM,EAAKA,EAAGH,UAAY,EACnC,CACA,MAAMM,GAAO,QAAO,CAChBC,aAAa,EACbC,aAA6DC,EAC7DC,OAA0E,MAC3EZ,GACEQ,EAAKK,iBAA6C,oBAAnBC,iBAChCN,EAAKK,gBAAkBE,KAASD,eAAeE,IAAID,IAEvD,MAAM,KAAEE,IAAS,QAAQlB,EAAUS,GAa7BU,EAAU,IAAIC,SAAS,MAAOF,EAArB,CAA2B,GAE1C,OADAC,EAAOE,KAAM,EACLxB,EAAaO,GAAOe,CAChC,G","sources":["webpack://CSH/./node_modules/vue/dist/vue.esm-bundler.js"],"sourcesContent":["import * as runtimeDom from '@vue/runtime-dom';\nimport { initCustomFormatter, warn, registerRuntimeCompiler } from '@vue/runtime-dom';\nexport * from '@vue/runtime-dom';\nimport { compile } from '@vue/compiler-dom';\nimport { isString, NOOP, extend, generateCodeFrame } from '@vue/shared';\n\nfunction initDev() {\n    {\n        initCustomFormatter();\n    }\n}\n\n// This entry is the \"full-build\" that includes both the runtime\nif ((process.env.NODE_ENV !== 'production')) {\n    initDev();\n}\nconst compileCache = Object.create(null);\nfunction compileToFunction(template, options) {\n    if (!isString(template)) {\n        if (template.nodeType) {\n            template = template.innerHTML;\n        }\n        else {\n            (process.env.NODE_ENV !== 'production') && warn(`invalid template option: `, template);\n            return NOOP;\n        }\n    }\n    const key = template;\n    const cached = compileCache[key];\n    if (cached) {\n        return cached;\n    }\n    if (template[0] === '#') {\n        const el = document.querySelector(template);\n        if ((process.env.NODE_ENV !== 'production') && !el) {\n            warn(`Template element not found or is empty: ${template}`);\n        }\n        // __UNSAFE__\n        // Reason: potential execution of JS expressions in in-DOM template.\n        // The user must make sure the in-DOM template is trusted. If it's rendered\n        // by the server, the template should not contain any user data.\n        template = el ? el.innerHTML : ``;\n    }\n    const opts = extend({\n        hoistStatic: true,\n        onError: (process.env.NODE_ENV !== 'production') ? onError : undefined,\n        onWarn: (process.env.NODE_ENV !== 'production') ? e => onError(e, true) : NOOP\n    }, options);\n    if (!opts.isCustomElement && typeof customElements !== 'undefined') {\n        opts.isCustomElement = tag => !!customElements.get(tag);\n    }\n    const { code } = compile(template, opts);\n    function onError(err, asWarning = false) {\n        const message = asWarning\n            ? err.message\n            : `Template compilation error: ${err.message}`;\n        const codeFrame = err.loc &&\n            generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\n        warn(codeFrame ? `${message}\\n${codeFrame}` : message);\n    }\n    // The wildcard import results in a huge object with every export\n    // with keys that cannot be mangled, and can be quite heavy size-wise.\n    // In the global build we know `Vue` is available globally so we can avoid\n    // the wildcard object.\n    const render = (new Function('Vue', code)(runtimeDom));\n    render._rc = true;\n    return (compileCache[key] = render);\n}\nregisterRuntimeCompiler(compileToFunction);\n\nexport { compileToFunction as compile };\n"],"names":["compileCache","Object","create","template","options","nodeType","innerHTML","key","cached","el","document","querySelector","opts","hoistStatic","onError","undefined","onWarn","isCustomElement","customElements","tag","get","code","render","Function","_rc"],"sourceRoot":""}